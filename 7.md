## 7 USER AUTHENTI

## 7.0 Create Account part One

#### [SchemaType.prototype.unique()](https://mongoosejs.com/docs/api.html#schematype_SchemaType-unique)

고유 인덱스를 선언함
제약 조건을 위반하면 Mongoose 유효성 검사 오류가 아니라 저장할 때 MongoDB에서 E11000 오류를 반환함.

`unique: true` :

- USER의 email 이나 username 은 딱 하나만 존재함
- 같은 email/usename을 가진 계정이 여러개면안됨

```js
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true },
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  name: { type: String, required: true },
  location: String,
});

const User = mongoose.model("User", userSchema);
export default User;
```

## 7.1 Create Account part Two

```js
// controller/userController
export const postJoin = async (req, res) => {
  const { username, email, password, name, location } = req.body;
  await User.create({
    username,
    email,
    password,
    name,
    location,
  });
  return res.redirect("/login");
};
```

postJoin 이후 terminal

```
$ monghsh
$ show dbs
$ use wetube
$ show collection
$ db.users.find()
```

## 7.2 Creating Account part Three

결정적 함수 (deterministic function)
같은 입력값에는 항상 같은 해시 결과값이 나옴

[비밀번호 털렸다고? 암호화. 해시함수. 5분 설명 영상](https://www.youtube.com/watch?v=67UwxR3ts2E)

`remove()` 명령어 실행이 안될 때
`db.users.remove()`는 deprecated되었기 때문에
`db.users.deleteMany({})`로 지우시면 됩니다.

[해시함수 테스트](https://emn178.github.io/online-tools/sha256.html)

#### bcrypt

- 암호를 해싱할 때 사용
- blowfish cipher 기반으로 만들어짐
- 여러 언어에서 사용가능

[bcrypt 설치](https://www.npmjs.com/package/bcrypt)
암호를 해시하는 데 도움이 되는 라이브러리입니다.
`npm i bcrypt`

```js
bcrypt.hash(유저 비밀번호 , db에 저장하기 전에 몇 번 해싱할건지, 해싱하고 나온 출력값: 콜백함수)
```

[`Schema.prototype.pre()`](https://mongoosejs.com/docs/api.html#schema_Schema-pre)

여기서의 this는 create 되는 user의 this를 가리킴
save 하기전에 입력한 비밀번호를 5번 해싱하고 저장

```js
userSchema.pre("save", async function () {
  this.password = await bcrypt.hash(this.password, 5);
});
```

## 7.3 Form Validation

### [$or](https://docs.mongodb.com/manual/reference/operator/query/or/#mongodb-query-op.-or)

`$or 연산자`는 둘 이상의 조건에 대해 논리적 OR 연산을 수행하고
조건 중 하나 이상을 충족하는 문서를 선택함

```js
db.inventory.find({ $or: [{ quantity: { $lt: 20 } }, { price: 10 }] });
```

```js
export const postJoin = async (req, res) => {
  const pageTitle = "join";
  const { username, email, password, password2, name, location } = req.body;

  // 비밀번호와 비밀번호확인이 동일하지 않을때
  if (password !== password2) {
    return res.render("join", {
      pageTitle,
      errorMessage: "Password confirmation does not match.",
    });
  }

  // username과 email이 db에 이미 존재할때
  const exists = await User.exists({ $or: [{ username }, { email }] });
  if (exists) {
    return res.render("join", {
      pageTitle,
      errorMessage: "This username/email is already taken.",
    });
  }
  await User.create({
    username,
    email,
    password,
    name,
    location,
  });
  return res.redirect("/login");
};
```

## 7.4 Status Codes

### [상태코드](https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C)

- **200(OK)**: 서버가 요청을 제대로 처리했다는 뜻이다. 이는 주로 서버가 요청한 페이지를 제공했다는 의미로 쓰임
- **400(Bad Request)**: 서버가 요청의 구문을 인식하지 못할 때 발생함. 클라이언트 측에서 문제가 있을 때 주로 발생
- **404(Not Found)**: 서버가 요청한 페이지를 찾을 수 없을 때 발생한다. 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 제공함

1. 구글 크롬에서 username과 pssword 정보를 가지고 요청을 보낸뒤
2. 응답 상태코드로 200을 받으면
3. 구글 크럼이 계정 새성이 성공적인 것으로 판단하고 pssword를 저장할 것이냐 묻는것
4. 에러를 보냈지만 상태코드는 200을 보내고 있기 때문에 이런 상황이 오는 것
5. 브라우저에게 render은 됐지만 에러가 있었음을 알려줘야 함.
6. clients errors 400 bad request: 클라이언트에서 발생한 에러때문에 요청을 처리하지 못할때 쓰는 것

브라우저에게 상황 알리기

- 상태코드 200 : 해당 URL을 브라우저 히스토리에 남김
- 상태코드 404 : 해당 URL을 브라우저 히스토리에 남기지 않음

#### [`res.status(code)`](https://expressjs.com/ko/api.html#res.status) [링크1](https://nodejs.org/api/http.html#http_response_statuscode)

response에 대한 HTTP 상태를 설정 (status를 설정)

## 7.5 Login part One

## 7.6 Login part Two

[bcrypt를 이용해서 비밀번호 비교](https://www.npmjs.com/package/bcrypt)

`password`: 유저가 입력한 비밀번호
`user.passwordHash`: DB에 해시화되서 저장된 비밀번호

```js
const match = await bcrypt.compare(password, user.passwordHash);
//return boolean
```

```js
import bcrypt from "bcrypt";

export const postLogin = async (req, res) => {
  const { username, password } = req.body;
  // 존재하지 않는 username 일 경우,
  const user = await User.findOne({ username });
  if (!user) {
    return res.status(400).render("login", {
      pageTitle: "Login",
      errorMessage: "An account with this username does not exists.",
    });
  }

  // 입력한 비밀번호가 맞는지 확인
  const isOkay = await bcrypt.compare(password, user.password);
  if (!isOkay)
    return res.status(400).render("login", {
      pageTitle: "Login",
      errorMessage: "Wrong password.",
    });

  return res.redirect("/");
};
```

## 7.7 Sessions and Cookies part One

### 세션

백엔드와 브라우저 간에 어던 활동을 했는지 기억하는 것

- 로그인 되어있으면, 현재 사용하고 이쓴 브라우저와 백엔드사이에 세션존재
- 2주정도후에 세션이 사라짐. 없어져서 다시 로그인해야함
- 세션= 브라우저와 백엔드 사이의 memory, history같은 것
- 작동하려면 백엔드와 브라우저가 서로에 대한 정보를가지고 있어야함

1.  로그인 페이지에서 HTTP 요청을 하면
2.  요청이 처리되고 끝나게 될대, 그 이후로는 백엔드가 아무것도 할 수 없음

- 백엔드와 브라우저간에 할수 있는게 없다는것
- home 으로가 get요청을 해도 백엔드가 HTML을 render하고나면 연결이 끝남
- 계쏙 연결이 유지되는 wifi랑 다름

#### stateless(무상태)

한 번 연결 되었다가 끝남
둘사이에 state가 없음
로그인시에 유저에게 정보를 줘야함ㅁ. 유저가 백엔드에 뭔가 요청할때마다 누가 요청하는지 알 수있게

조그만한 텍스트를 줌
유저가 우리에게 요청을 보낼때마다 그 텍스트를 같이 보내달라고함 => 인식 구별가능
: 유저가 누구인지 알수 있게 해주는 것

### [express-session](https://www.npmjs.com/package/express-session)

Express용 세션 미들웨어
세션 데이터는 쿠키 자체에 저장되지 않고 세션 ID에만 저장됨.
세션 데이터는 서버 측에 저장됨
`npm i express-session`

#### [Session 사용 예시](https://github.com/expressjs/session#example)

`req.session.id` 또는 `req.sessionID`
브라우저가 request할 때 같이 보내는 `session id`

#### [secret](https://github.com/expressjs/session#secret)

세션 ID 쿠키에 서명하는데 사용
secret 값을 변경하면 기존에 존재하던 세션들이 모두 무효화됨

#### [resave (변경 사항이 없어도 저장)](https://github.com/expressjs/session#resave)

request하는 동안 세션이 수정되지 않은 경우에도 세션이 세션 저장소에 다시 저장되도록 함

#### [saveUninitialized (세션 초기화 전에도 저장)](https://github.com/expressjs/session#saveuninitialized)

"초기화되지 않은" 세션을 저장소에 강제로 저장함

```js
import session from "express-session";

//session 모듈 사용
app.use(
  session({
    secret: "Hello!",
    resave: true,
    saveUninitialized: true,
  })
);

//세션스토어에 존재하는 모든 세션데이터 조회
app.use((req, res, next) => {
  req.sessionStore.all((error, sessions) => {
    console.log(sessions);
    next();
  });
});
```

## 7.8 Sessions and Cookies part Two

세션 : 서버측에서 제공해주는 데이터
쿠기 : 클라이언트측에서 저장하고 사용하는 데이터

`req.sessionStore()` :

1. 처음에는 undefine : 세션은 서버에서 만들어줘야함. 첫 요청에는 가지고 있지않음.
   - exprees-session에서 세션id 생성, 브라우저에게 전달
2. 첫 번째요청 이후 넘겨준 세션데이터(세션id)를 클라이언트가 쿠키에 세션ID를 저장함
3. 클라이언트가 매 요청마다 서버에게 세션ID를 전달해 보여줌
   - 쿠키에 저장한 세션id를 통해 다시 방문 할때마다 계속 로그인을 유지시킬 수 있음
4. 세션은 서버가 만들어서 제공해주기 때문에 서버가 재부팅되면 세션도 초기화됨
   - DB에 저장하여 관리
   - 실 운영에는 서버가 꺼지는 일이없기때문

## 7.9 Logged In User

## 7.10 Logged In User part Two

#### [res.locals](https://expressjs.com/ko/api.html#res.locals)

request 범위가 지정된 response 로컬 변수를 포함하는 객체이므로 request, response 주기동안 렌더링된 view에서만 사용할 수 있음
(Pug나 EJS같은 템플릿 엔진에서 사용 가능하다는 의미)
이 속성은 request path, 인증된 사용자, 사용자 설정 등과 같은 request level의 정보를 노출하는 데 유용함.

```js
// 사용 예시
app.use(function (req, res, next) {
  res.locals.user = req.user;
  res.locals.authenticated = !req.user.anonymous;
  next();
});
```

## 7.11 Recap

# 7.12 MongoStore

# 7.13 Uninitialized Sessions

# 7.14 Expiration and Secrets

# 7.15 Environment Variables

# 7.16 Github Login part One

# 7.17 Github Login part Two

# 7.18 Github Login part Three

# 7.19 Github Login part Four

# 7.20 Github Login part Five

# 7.21 Github Login part Six

# 7.22 Log Out

# 7.23 Recap
