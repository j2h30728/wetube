## 7 USER AUTHENTI

## 7.0 Create Account part One

#### [SchemaType.prototype.unique()](https://mongoosejs.com/docs/api.html#schematype_SchemaType-unique)

고유 인덱스를 선언함
제약 조건을 위반하면 Mongoose 유효성 검사 오류가 아니라 저장할 때 MongoDB에서 E11000 오류를 반환함.

`unique: true` :

- USER의 email 이나 username 은 딱 하나만 존재함
- 같은 email/usename을 가진 계정이 여러개면안됨

```js
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true },
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  name: { type: String, required: true },
  location: String,
});

const User = mongoose.model("User", userSchema);
export default User;
```

## 7.1 Create Account part Two

```js
// controller/userController
export const postJoin = async (req, res) => {
  const { username, email, password, name, location } = req.body;
  await User.create({
    username,
    email,
    password,
    name,
    location,
  });
  return res.redirect("/login");
};
```

postJoin 이후 terminal

```
$ monghsh
$ show dbs
$ use wetube
$ show collection
$ db.users.find()
```

## 7.2 Creating Account part Three

결정적 함수 (deterministic function)
같은 입력값에는 항상 같은 해시 결과값이 나옴

[비밀번호 털렸다고? 암호화. 해시함수. 5분 설명 영상](https://www.youtube.com/watch?v=67UwxR3ts2E)

`remove()` 명령어 실행이 안될 때
`db.users.remove()`는 deprecated되었기 때문에
`db.users.deleteMany({})`로 지우시면 됩니다.

[해시함수 테스트](https://emn178.github.io/online-tools/sha256.html)

#### bcrypt

- 암호를 해싱할 때 사용
- blowfish cipher 기반으로 만들어짐
- 여러 언어에서 사용가능

[bcrypt 설치](https://www.npmjs.com/package/bcrypt)
암호를 해시하는 데 도움이 되는 라이브러리입니다.
`npm i bcrypt`

```js
bcrypt.hash(유저 비밀번호 , db에 저장하기 전에 몇 번 해싱할건지, 해싱하고 나온 출력값: 콜백함수)
```

[`Schema.prototype.pre()`](https://mongoosejs.com/docs/api.html#schema_Schema-pre)

여기서의 this는 create 되는 user의 this를 가리킴
save 하기전에 입력한 비밀번호를 5번 해싱하고 저장

```js
userSchema.pre("save", async function () {
  this.password = await bcrypt.hash(this.password, 5);
});
```

## 7.3 Form Validation

### [$or](https://docs.mongodb.com/manual/reference/operator/query/or/#mongodb-query-op.-or)

`$or 연산자`는 둘 이상의 조건에 대해 논리적 OR 연산을 수행하고
조건 중 하나 이상을 충족하는 문서를 선택함

```js
db.inventory.find({ $or: [{ quantity: { $lt: 20 } }, { price: 10 }] });
```

```js
export const postJoin = async (req, res) => {
  const pageTitle = "join";
  const { username, email, password, password2, name, location } = req.body;

  // 비밀번호와 비밀번호확인이 동일하지 않을때
  if (password !== password2) {
    return res.render("join", {
      pageTitle,
      errorMessage: "Password confirmation does not match.",
    });
  }

  // username과 email이 db에 이미 존재할때
  const exists = await User.exists({ $or: [{ username }, { email }] });
  if (exists) {
    return res.render("join", {
      pageTitle,
      errorMessage: "This username/email is already taken.",
    });
  }
  await User.create({
    username,
    email,
    password,
    name,
    location,
  });
  return res.redirect("/login");
};
```

## 7.4 Status Codes

### [상태코드](https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C)

- **200(OK)**: 서버가 요청을 제대로 처리했다는 뜻이다. 이는 주로 서버가 요청한 페이지를 제공했다는 의미로 쓰임
- **400(Bad Request)**: 서버가 요청의 구문을 인식하지 못할 때 발생함. 클라이언트 측에서 문제가 있을 때 주로 발생
- **404(Not Found)**: 서버가 요청한 페이지를 찾을 수 없을 때 발생한다. 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 제공함

1. 구글 크롬에서 username과 pssword 정보를 가지고 요청을 보낸뒤
2. 응답 상태코드로 200을 받으면
3. 구글 크럼이 계정 새성이 성공적인 것으로 판단하고 pssword를 저장할 것이냐 묻는것
4. 에러를 보냈지만 상태코드는 200을 보내고 있기 때문에 이런 상황이 오는 것
5. 브라우저에게 render은 됐지만 에러가 있었음을 알려줘야 함.
6. clients errors 400 bad request: 클라이언트에서 발생한 에러때문에 요청을 처리하지 못할때 쓰는 것

브라우저에게 상황 알리기

- 상태코드 200 : 해당 URL을 브라우저 히스토리에 남김
- 상태코드 404 : 해당 URL을 브라우저 히스토리에 남기지 않음

#### [`res.status(code)`](https://expressjs.com/ko/api.html#res.status) [링크1](https://nodejs.org/api/http.html#http_response_statuscode)

response에 대한 HTTP 상태를 설정 (status를 설정)

## 7.5 Login part One

## 7.6 Login part Two

[bcrypt를 이용해서 비밀번호 비교](https://www.npmjs.com/package/bcrypt)

`password`: 유저가 입력한 비밀번호
`user.passwordHash`: DB에 해시화되서 저장된 비밀번호

```js
const match = await bcrypt.compare(password, user.passwordHash);
//return boolean
```

```js
export const postLogin = async (req, res) => {
  const { username, password } = req.body;
  // 존재하지 않는 username 일 경우,
  const user = await User.findOne({ username });
  if (!user) {
    return res.status(400).render("login", {
      pageTitle: "Login",
      errorMessage: "An account with this username does not exists.",
    });
  }

  // 입력한 비밀번호가 맞는지 확인
  const isOkay = await bcrypt.compare(password, user.password);
  if (!isOkay)
    return res.status(400).render("login", {
      pageTitle: "Login",
      errorMessage: "Wrong password.",
    });

  return res.redirect("/");
};
```

## 7.7 Sessions and Cookies part One

## 7.8 Sessions and Cookies part Two

## 7.9 Logged In User

## 7.10 Logged In User part Two

## 7.11 Recap

# 7.12 MongoStore

# 7.13 Uninitialized Sessions

# 7.14 Expiration and Secrets

# 7.15 Environment Variables

# 7.16 Github Login part One

# 7.17 Github Login part Two

# 7.18 Github Login part Three

# 7.19 Github Login part Four

# 7.20 Github Login part Five

# 7.21 Github Login part Six

# 7.22 Log Out

# 7.23 Recap
