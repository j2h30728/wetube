# 8 USER PROFILE

## 8.0 Edit Profile GET

## 8.1 Protector and Public Middlewares

### middlware 사용

로그인 유무에 따라서 페이지 경로 제한

```js
//middleware.js

//로그인 되어있을 경우 통과, 그렇지않을 경우 login 페이지로 리다이렉트
export const protectMiddleware = (req, res, next) => {
  if (req.session.loggedIn) {
    return next();
  } else {
    return res.redirect("/login");
  }
};

//로그인 되어있지 않을 경우 통과, 그렇지않을 경우 / 페이지로 리다이렉트
export const publickOnlyMiddleware = (req, res, next) => {
  if (!req.session.loggedIn) {
    return next();
  } else {
    return res.redirect("/");
  }
};
```

#### all

`.get().post()` 의 컨트롤러에 모두 미들웨어로 거침

```js
//rooteRouter.js
rootRouter
  .route("/join")
  .all(publickOnlyMiddleware)
  .get(getJoin)
  .post(postJoin);
rootRouter
  .route("/login")
  .all(publickOnlyMiddleware)
  .get(getLogin)
  .post(postLogin);

//userRouter.js
userRouter.route("/edit").all(protectMiddleware).get(getEdit).post(postEdit);
userRouter.get("/github/start", publickOnlyMiddleware, startGithubLogin);
userRouter.get("/github/finish", publickOnlyMiddleware, finishGithubLogin);
```

## 8.2 Edit Profile POST part One

[`Model.findByIdAndUpdate()`](https://mongoosejs.com/docs/api.html#model_Model.findByIdAndUpdate)

문서의 \_id 필드로 mongodb findAndModify 업데이트 명령을 실행함.
`findByIdAndUpdate(id, ...)`는 `findOneAndUpdate({ \_id: id }, ...)`와 동일

```js
// 사용 예시
Model.findByIdAndUpdate(id, { name: "jason bourne" }, options, callback);

// is sent as (+타입스크립트)
Model.findByIdAndUpdate(
  id,
  { $set: { name: "jason bourne" } },
  options,
  callback
);
```

## 8.3 Edit Profile POST part Two

#### option

`{new:true}` : 리턴값을 업데이트된 값을 넣어줌
기재하지 않는 디폴트 값은 업데이트 전의 오리지널 값을 리턴하마

```js
const updateUser = await User.findByIdAndUpdate(
  _id,
  {
    name,
    email,
    username,
    location,
  },
  { new: true } // 해당 옵션 값을 넣을경우, 리턴값이 업데이트된 값이 됨
);
req.session.user = updateUser;
```

## 8.4 Change Password part One

## 8.5 Change Password part Two

```js
export const getChangePassword = (req, res) => {
  if (req.session.socialOnly === true) {
    return res.redirect("/");
  }
  return res.render("users/change-password", { pageTitle: "Change Password" });
};
export const postChangePassword = async (req, res) => {
  const {
    session: {
      user: { _id },
    },
    body: { oldPassword, newPassword, newPasswordConfirm },
  } = req;
  const user = await User.findById({ _id });

  // await user.save()에서 데이터이스에서 데이터가 수정됨
  user.password = newPassword;
  user.location = "이거되나?";

  // 비밀번호를 다섯번 해싱하는 pre 함수 트리거시킴 userSchema.pre("save",..)
  // 해싱된 비밀번호를 함께 데이터베이스에 저장
  await user.save();

  // 해커들이 로직 파악 후, 302 redirect를 프록시로 통해서 막은후 이전 세션데이터를 활용할수 있음
  // 안전하게 session을 destroy 시킴
  req.session.destroy();

  //비밀번호 변경완료 된후, login 페이지로 redirect시킴
  return res.redirect("/login");
};
```

#### [bcrypt](https://www.npmjs.com/package/bcrypt)

```js
// 비밀번호 비교
//pasword : 입력한 비밀번호
//user.passwordHash : 데이터베이스에 존재하는 hash된 비밀번호
const match = await bcrypt.compare(password, user.passwordHash);
```

#### [`Model.findByIdAndUpdate()`](https://mongoosejs.com/docs/api.html#model_Model.findByIdAndUpdate)

`findByIdAndUpdate`로는 `pre('save')`를 실행시키지 않기 때문에 비밀번호가 해시화되지 않고 DB에 저장되게 됨.
그래서 `save()`메서드를 통해 `pre('save')`를 실행시켜 비밀번호를 해시화한 후 DB에 저장될 수 있도록 해줌

#### [`Model.prototype.save()`](https://mongoosejs.com/docs/api.html#model_Model-save)

`findByIdAndUpdate`를 이용해서 Document업데이트 후 save하기
앞서 했던 것처럼 `findByIdAndUpdate`를 통해 Document를 업데이트 시키고 업데이트된 최신 Document를 받아서 save이 가능함
(자바스크립트로 진행한다면 $set은 사용하지 않아도 됨)

```js
const updatedUser = await User.findByIdAndUpdate(
  loggedInUser?._id,
  { $set: { password: newPassword } },
  { new: true }
);
await updatedUser?.save();
```

## 8.6 File Uploads part One / 8.7 File Uploads part Two

1. middleware 생성
   `export const uploadFiles = multer({ dest: "uploads/" });`
   - `dest: "uploads/"` 이기때문에 자동으로 root에서 uploads 폴더가 생성됨
   - 웹페이지에서 업로드 시키는 파일의 정보가 updloads 폴더에 쌓이게됨
2. view 에서 filed을 받아올 form을 multer 양식에 맞게 수정
   ```js
   form(method="POST", enctype="multipart/form-data") //인코딩타입 추가 꼭 필요
   label(for="avatar") Avatar
   input#avart(type="file", name="avatar", accept="image/*") //파일을 받을 name 꼭 추가
   ```
3. userRouter에 추가
   ```js
   userRouter
     .route("/edit")
     .all(protectMiddleware)
     .get(getEdit)
     .post(uploadFiles.single("avatar"), postEdit);
   // postEdit controller 실행 하기전에 upoadFiles.single실행
   // uploadFiles.single("avatar") : 'avatar'라는 Name 값 한개를 단일 파일을 수락하여 req.file에 저장
   ```
4. userController 의 postEdit에 `req.file`로 값을 받아옴
   ```js
   export const postEdit = async (req, res) => {
   const {
   session: {
     user: { _id, email: originalEmail, username: originUsername },
   },
   body: { name, email, username, location },
   file, //req.file 로 받아옴
   } = req;
   console.log(file)
   ```
5. `console.log(file)` 의 결과값
   ```json
   {
     "fieldname": "avatar", // pug form에 정의된 필드명 (input name)
     "originalname": "cat.png", // 실제 사용자가 업로드한 파일 이름과 확장자
     "encoding": "7bit", //파일의 인코딩 타입
     "mimetype": "image/png", // 파일의 mime 타입
     "destination": "uploads/", // 파일이 저장된 폴더
     "filename": "de8d7b8f9533a1c77dc07bee85698a08", //destination에 저장된 파일 명
     "path": "uploads/de8d7b8f9533a1c77dc07bee85698a08", // 업로드된 파일의 전체 경로
     "size": 2478532 //전체 파일의 Buffer
   }
   ```
6. 업로드 된 파일의 경로를 db와 session에 업데이트
   **DB에는 파일을 저장하지않고 파일 경로를 저장함!!!**(원본은 amazone의 하드드라이브 같은곳에 저장)
   ```js
   const updateUser = await User.findByIdAndUpdate(
     _id,
     {
       avatarUrl: file ? file.path : avatarUrl,
       // upload된 파일이 없으면 (file === undefined) 이므로
       // file 이 존재하면 file.path , 없으면 기존에 session에 존재하는 avatartUrl 값을 가지고옴
       name,
       email,
       username,
       location,
     },
     { new: true }
   );
   req.session.user = updateUser;
   ```
7. 브라우저가 uploads 폴더에 있는 내용을 볼수 있게 해야함
   - 현재 코드에서 브라우저가 서버에 있는 파일에 접근할 수가 없음
   ```js
   // edit-profile.pug
   img((src = "/" + loggedInUser.avatarUrl), (width = "100"), (height = "100"));
   // '/' 을 추가해 절대 경로를 줌
   ```
   - 브라우저가 서버의 어떤 폴더로든 갈 수있게되면 보안상 좋지않음.
   - 브라우저가 어떤 폴더 및 파일을 볼 수 있는지 설정함.
   - [**static fils serving**](#88-static-files-and-recap)를 활성화 시킴
     = 폴더 전체를 브라우저에게 노출 시킴

---

[Multer](https://www.npmjs.com/package/multer)
[한글 번역 버전](https://github.com/expressjs/multer/blob/master/doc/README-ko.md)
Multer는 주로 파일 업로드에 사용되는 multipart/form-data를 처리하기 위한 node.js 미들웨어
주의! Multer는 `multipart(multipart/form-data)`가 아닌 form을 처리하지 않음

> `npm i multer`
>
> `enctype="multipart/form-data"`

**`multer(opts)`**
Multer는 옵션 객체를 허용
가장 기본 옵션인 `dest` 요소는 Multedr에게 파일을 어디로 업로드 할지 알려줌
옵션객체를 생략했다면, 파일은 디스크가 아닌 메모리에 저장될 것

기본적으로 multer는 이름이 중복되는 것을 방지하기 위해 파일의 이름을 재작성함. 필요에 따라 해당 함수는 커스텀마이징 가능
**dest 또는 storage**: 파일을 저장할 위치
**fileFilter**: 어떤 파일을 허용할지 제어하는 함수
**limits**: 업로드된 데이터의 한계
**preservePath**: 파일의 base name 대신 보존할 파일의 전체경로

사용 예시

```js
const express = require("express");
const multer = require("multer");
const upload = multer({ dest: "uploads/" });

const app = express();

app.post("/profile", upload.single("avatar"), function (req, res, next) {
  // req.file 은 `avatar` 라는 필드의 파일 정보입니다.
  // 텍스트 필드가 있는 경우, req.body가 이를 포함할 것입니다.
});

app.post(
  "/photos/upload",
  upload.array("photos", 12),
  function (req, res, next) {
    // req.files 는 `photos` 라는 파일정보를 배열로 가지고 있습니다.
    // 텍스트 필드가 있는 경우, req.body가 이를 포함할 것입니다.
  }
);

const cpUpload = upload.fields([
  { name: "avatar", maxCount: 1 },
  { name: "gallery", maxCount: 8 },
]);
app.post("/cool-profile", cpUpload, function (req, res, next) {
  // req.files는 (String -> Array) 형태의 객체 입니다.
  // 필드명은 객체의 key에, 파일 정보는 배열로 value에 저장됩니다.
  //
  // e.g.
  //  req.files['avatar'][0] -> File
  //  req.files['gallery'] -> Array
  //
  // 텍스트 필드가 있는 경우, req.body가 이를 포함할 것입니다.
});
```

텍스트 전용 Multipart 폼을 처리해야하는 경우, 사용하는 Multer메소드

- `.single()`, `.array()`, `.fields()`
  **.single(fieldname)**
  이름이 fieldname인 단일 파일을 수락
  단일 파일은 `req.file`에 저장됨

## 8.8 Static Files and Recap

#### [static files serving](https://expressjs.com/en/starter/static-files.html)

[`express.static(root, [options])`](https://expressjs.com/ko/api.html#express.static)

Express에 내장된 미들웨어 기능.
정적 파일을 제공하며 serve-static을 기반으로 함.
root 인수는 static asset을 제공할 root 디렉토리를 지정.
이 함수는 `req.url`을 제공된 root 디렉토리와 결합하여 제공할 파일을 결정.

```js
app.use("/uploads", express.static("_uploads"));
//정적 파일을 제공할 디렉토리 : '/uploads'
// "_uploads"라는 디렉토리에서 정적파일을 제공함

//http://localhost:4000/uploads/'req.file.path'
```

##### 문제점

1. 현재 웹페이지를 실행시키는 서버는 계속 켜 있지않음.
   또한, 서버는 재시작할 때마다 초기화 되기 때문에 파일을 보관하기에 적합하지 않음
   1. 서버가 두개라면? : 웹페이지 실행서버, 이미지파일 보관 서버
   2. 서버가 죽는다면? : 이미지 파일 보관 서버가 죽는다면 데이터는 전부 사라지게 될 터...
2. 데이터 베이스에는 파일을 저장하지 않고 파일위치를 저장함
   1. 원본 파일은 amazone의 하드드라이브 같은 곳에 저장

## 8.9 Video Upload

## 8.10 User Profile

## 8.11 Video Owner

## 8.12 Video Owner part Two

## 8.13 User's Videos

## 8.14 Bugfix

## 8.15 Conclusions
